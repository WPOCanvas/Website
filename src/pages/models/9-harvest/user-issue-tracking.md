---
templateKey: 'model-post'
title: '3-user issue tracking'
date: 2019-07-25T15:04:10.000Z
featuredpost: true
indexingField: 6-Harvest
featuredimage: '/img/user-issue-tracking-img-1.jpeg'
description: 'user issue tracking'

tags:
  - WPO introduction
  - Value Proposition
  - Organization
  - WPO canvas
  - Winning product organization
  - Winning products
  - types of software
  - context-competitor-analysis
---

##Why? 


Issue tracking provides a structured way to capture and process the various questions, ideas, decisions, defects, and other assorted challenges that come up over the course of a project. Issue tracking systems, commonly referred to as ITS, are software applications that provide a ticketing system to record and follow the progress of every issue identified by a computer user until the issue is resolved. Issue tracking is really just a team todo list with a heavy focus on accountability and progress. Unlike a todo list, however, issue tracking not only helps ensure that work gets done, but that it gets done correctly. It will ensure that the customers’ concerns are heard and the corrective actions are being taken. 

 

You want to ship software as quickly as possible with the fewest issues possible. By themselves, these two concepts are at odds with each other. In order to prevent issues, you need to invest time. You can always ship faster by lowering quality. The key is finding the middle ground that works for your team. So let’s see how issue tracking helps you balance the two to save time and money.

 

##1. CATCH ISSUES EARLIER

 

It’s a simple fact that the earlier you catch a problem, the less time and money will be required to address it. 2 If you uncover an issue before writing any code, the cost is almost zero, but if that same issue makes it all of the way to production and affects customers, the cost is significantly higher. At that point, it requires developer time, support team time, and customer frustration.

While other complementary processes can catch issues before they even make it to testing, Issue tracking in conjunction with a formal quality assurance phase can serve as the last line of defense in finding and fixing issues before the costs increase dramatically. Once something is live, the developers have moved onto the next thing, and it’s going to take them longer to switch gears and fix the problem. In the meantime, that issue lingers in production, and more customers are affected. The issue is creating more problems for customers. Those customers are creating more support requests.

 

##2. FIND MORE ISSUES

 

While the various forms of automated tools play key roles in discovering bugs, the human brain and associated senses are number one testing tool. In addition to finding issues before they reach production, a manual QA process helps catch certain types of problems that other forms of automated testing or code analysis may miss.

By using a testing phase to complement your automated processes, you enable team members to catch more subtle or subjective problems that a developer may not even be aware of. There is certainly some overlap in potential defects discovered between multiple testing techniques, but for the highest discovery rate, complementing automated processes with human processes generates the best results.

 

##NON-TECHNICAL TEAM MEMBER INVOLVEMENT



One of the biggest benefits of a formal issue tracking and quality assurance process is that your non-technical team members can help test before releasing to the public. Often, your non-technical team members are the business experts and the only people versed enough in the business requirements to catch the subtle bugs in business logic. Ideally, you’ll have a formal acceptance testing phase where your clients or stakeholders can review the product in a staging or other pre-production environment to approve the end result before shipping.

 

##A SECOND SET OF EYES



Another commonly overlooked benefit of formal testing is ensuring that developers don’t test their own modules. And developers should avoid doing quality assurance for their own work. For example, let’s say a developer’s understanding of the requirements is wrong. In that scenario, any tests or code they write will also be wrong, and no amount of testing by that developer will be able to catch the problem.

 With a dedicated manual testing phase, you’re able to have people cross-test each others modules to ensure that subtle mistakes like that don’t slip through. Moreover, even if the developer fully understands the requirements, they’re often too close to notice problems with their own code. So having a second set of eyes involved is important to help find as many problems as possible.

Just like an author shouldn’t rely entirely on spell checking software and not hire an editor, you probably don’t want to ship software with having a second set of eyes reviewing the results.

 

##BUILDING VS. BREAKING MINDSETS



Even if you do have developers testing their own modules, having a period of time dedicated to finding defects rather than writing new code can make a huge difference in their discovery rate. There’s a huge gap between creation and destruction mindsets. When developers write code, their brain is in a creation mindset. They aren’t actively looking for loopholes or thinking about edge cases and unusual scenarios. A formal testing phase however enables the team to think more destructively and focus on uncovering problems rather than just writing new code. This is the reason that we encourage teams to slow down and break things.

 

##BROWSER/PLATFORM/DEVICE TESTING



Finally, developers are also more likely to miss cross-platform issues during development. Whether it’s testing against different operating systems, devices, or browsers, developers spend the majority of their time in their work environment. Even if they do set aside significant time testing in other environments, it will only ever be a fraction of the time spent developing in their primary environment.

As a result, your team likely isn’t testing enough across different platforms, operating systems, or browsers. A formal testing phase is the ideal place to do this testing and have different people use their primary environments to do the testing. That is, if you develop on Macs, you’ll want to ensure that you have a few Windows users testing from their own computers.

 

##3. GET IT RIGHT THE FIRST TIME



The primary difference between formal issue tracking and a todo list is the review process. Without the review, or retesting, process, you will invariably run into cases where bugs are fixed incorrectly. In some cases, the “fix” may not work at all. Keep in mind that every time new code is written, that new code is introducing the opportunity for additional bugs to sneak in. If your team isn’t retesting resolved bugs, then they’re only doing the job halfway.

Similarly, unless your developers also happen to be the domain experts, it’s likely that they don’t have the knowledge to determine whether their solution is entirely correct. Or, they could simply misunderstand the problem. That’s where issue tracking’s review process really helps. Whenever someone reports an issue, they’re the best person to officially green light a resolution. Otherwise, a developer may think something is fixed but implement the a solution incorrectly due to a misunderstanding of either the business logic or the details of the bug report.

 

Equally important with the review process is the discussion process. Issues aren’t as simple as todos because they usually involve discussion, debate, and, ultimately, agreement. Instead of a team member going rogue and just “fixing” something, key team members are able to offer their input so that the right decision is made. What’s even better is that a month down the road when you’re second-guessing a decision, you have a written record of how the decision was made—saving even more time because you don’t have the same discussion all over again.



##4. WORK ON THE RIGHT THINGS



With any software project, it’s challenging to choose the right things to work on, and it’s often even tougher for team members to know what they’re expected to work on next. Prioritization involves a mix of both objective and subjective variables. Are there dependent issues? Is it a show-stopper? Is there a workaround? How many customers does it impact? Is there a fixed due date? How much time/money/materials is available to fix this? How much time/money/materials would be required to fix it? As a result, boiling issues down to their true priorities is a task best suited to project managers, clients, or stakeholders as they have the best high level view of the answers to these questions.

 

Working on new features without first fixing the bugs in existing features is a recipe for disaster.

 

 

A centralized issue tracker in conjunction with a process for handling prioritization helps minimize developer confusion by freeing them from worrying about priority and letting them focus exclusively on what’s next for them. Instead of having developers swim through varying, potentially competing, data points that affect priority, they’re left with a simple priority and no room for confusion.

 

Similarly, by handling bugs, issues, questions, ideas, enhancements, and everything in a centralized tool, you’re able to prioritize everything against each other. If your feature roadmap is separate from your bug database, it’s nearly impossible to know what’s most important. Separating your new development work from your bug fixing work also has the side effect of relegating bugs to second-class citizens. As a result, it’s easier for the defects to be ignored, and that’s dangerous. Working on new features without first fixing the bugs in existing features is a recipe for disaster. Centralizing everything makes you more efficient when prioritizing work and your team more efficient because they don’t have to wonder what they should do next.

 

##5. CREATE HAPPIER CUSTOMERS

 

The biggest benefit of a good issue tracking process is happier customers. Fewer bugs means lower support costs, but not having to deal with bugs at all makes customers more efficient and happier with your software. In addition to happiness, your customers will see your software as more reliable. They’ll be more comfortable trusting it, and thus, recommending it.

 

You’re not only saving your team time dealing with production issues, but you’re also saving your customer time because they don’t have to report the issues. Of course, don’t overlook the fact that your customers are going to be a whole lot less likely to report issues than your in-house quality assurance team. So for every bug report you get, another 5-10 customers have problem encountered the same problem. Or, in some cases, your customers may just overlook a bug that’s not serious but silently increase their lack of faith in your software.

 

##Inputs 
Product support organizations

 

##Outputs 
Hot-fix Process

 

##How? 
 

Manual testing and issue tracking can help. They're only one component of a good holistic QA process, but they're a key component for finding an entire class of issues that are unlikely to be discovered with any other method. Now that we have a high-level overview of how the various tools and processes fit together, we can see how they fit into a basic project timeline

 

Example Tools

 

1.   Jira

2.   Trac

3.   Redmine

4.   Webissues

5.   Asana

 ![flavor wheel](/img/user-issue-tracking-img-1.jpeg)



